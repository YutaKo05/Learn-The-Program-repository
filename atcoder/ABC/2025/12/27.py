# A
# 1年D日、7日ごとコンテスト
D,F = map(int,input().split())


# 1年のうちF日目に開催された
# その次の年のコンテストの1年のうちに開催されますか？？

# なんで1年のうち4日目だったら次の年3日目なの？？
# DのうちのF日目に開催

# 10日で5日目に開催
# 残りの日数を足すので10-5=5で　7-5=2で2日目に開催
# イメージ　５＋７＝１２
# 12-10=2　これだけ

# F が D 以下である間 F に 7 を加算し続け、F−D を出力すると答えとなります。
# F+7をし続ければいい

while F<=D:
  # Fに7を足し続ける
  F += 7

print(F-D)
  
# これが最強
# print(7 - (D - F) % 7)


# 反省
# すぐに思いつかなかった。
# インクリメントの符号の位置間違えた。


# B
# 標準入力
# 長さ
N,M = map(int,input().split())
# 数字列
S = input() 
# 数字列
T = input()

# 0回以上好きな回数行うことができる作業
# Tから一文字選び、選んだ数字を１増やす
# 選んだ数字を0~9に変換するみたいな感じ

# 編集距離みたいな感じじゃね？？

# ロジック分解
# 好きな回数を行うは逆算的にやらないとだめ、
# TをSの部分文字列（連結）に必要な回数の最小値を求める

# 部分文字列なので inを使って存在を確認する必要ある
# Sの中のどの箇所に全探索すればいいのかを考える
# 全ての候補に対してそれぞれの操作回数を計算して、その中の最小値が答え

# Tの長さを変えず。各文字を何回インクリメントすればSの部分に一致するか

ans = M*9

# Sの開始位置をi→N-Mまで
for i in range(N-M+1):
  current_cost = 0
  # 文字列Tの長さまで回す
  for j in range(M):
    # ここで操作を好きな回数行うの部分に当たる
    # 任意の開始位置
    diff = (int(S[i+j]) - int(T[j]) + 10) % 10
    # 差分を加算する
    current_cost += diff
  ans = min(ans, current_cost)

print(ans)


# 反省
# 全くわかんなかった
# 好きな回数を選ぶ系が苦手すぎる



# C
N = int(input())
# スタックを用意
q = []
# 削除するよう旨があるのであれば、stashとpopを考えるべし
# 

# 条件は満たすようにする必要がある
# forの中に、ifを入れるのは当たり前

for v in list(map(int,input().split())):
  # 標準入力からfor文で、配列に入れていく
  q.append(v)
  print(q)
  # 条件式
  # 1 以上∣A∣−3 以下の整数 
  # 条件式にAは4つあったので、長さ4つ以上の条件を加える。
  # さらに、値も同じじゃないといけないのでそれも条件
  # 末尾なので、q[-1],q[-2],q[-3],q[-4]
  if len(q) >= 4 and q[-1] == q[-2] == q[-3] == q[-4]:
    # Aから4つ削除する作業
    for i in range(4):
      #　popで削除
      q.pop()

print(len(q))


# 標準入力
# 10
# 1 1 1 4 4 4 4 1 2 3
# としたとき

# 実行動作解剖
[1]
[1, 1]
[1, 1, 1]
[1, 1, 1, 4]
[1, 1, 1, 4, 4]
[1, 1, 1, 4, 4, 4]
[1, 1, 1, 4, 4, 4, 4]
# ここで、条件式発動、4つ同じなので削除
# その後、１が入ってしまったので、また、削除
[1, 1, 1, 1]
# 残り、２と３を入れるだけになった。
[2]
[2, 3]
2

# 反省
# 入れて取り出すような反復作業が問題の文脈から取れるのであれば、スタックとキューを使ったらいいのではと考えるべき


# 反省
# ケースを知れてよかったが総じてむずい
# 
