# A
N = int(input())

ans = pow(2,N)-2*N
print(ans)

# 簡単すぎた

# B
N_str = input()
n =int(N_str)

# 集合を設定する
seen = set()

# Nがハッピー数かどうか判定する

# ハッピー数とは？？
# 十進法表記→２乗和を取った整数に置き換える
# 

# 各桁を累乗していって足すような処理を行う必要ある

# ロジック分解
# 各桁ずつ取り出す必要ある(インデックスで対応できるかも)
# その各行をそれぞれ2乗する
# これでいけそう

# 検討
# 数字を一桁ずつ配列に累乗する？？

# forループをここにいい感じに書く必要あり
# 問題はいつまで繰り返すのか
# nが1じゃなくて、集合に同じ値が入らなければ繰り返す
while n != 1 and n not in seen:
  # 現在の値を登録
  seen.add(n)
  print(seen)
  next_n =0
  #一桁ずつ取得し、２乗して足す。
  for digit_char in str(n):
    digit = int(digit_char)
    next_n  += digit ** 2
    print(next_n)
  # 次の数字に置き換え
  n = next_n
  
# 判別ロジック
if n == 1:
  print("Yes")
else:
  print("No")

# 反省
# 判別ロジックとかwhile使えばいいはわかった。
# ただ、終了条件とか、各桁を取り出して２乗して足すとかの実装ができなかった。
# 各桁を取り出すのは、文字列にしてforループでいいのはわかったので、悔しいところ
# やはり集合を設定するという発想はなかなか出てこないなあ

# 集合を使うケース例
# 無限ループを防止するために、過去に出現した値を保存しておく場合など
# 今回の例みたいな感じ

# すでに使われた名前の管理など
used_ids = {"tanaka", "sato"}

name = "tanaka"

if name in used_ids:
    print("その名前はすでに使われています")
else:
    print("その名前は使えます！")
    
# set inで計算した方が　list in よりも高速に動作する
# 計算量がO(N) vs O(1)の違い　そりゃ1の方が早いよね


# C
# クソムズ これ途中

N = int(input())

# いい整数とは？
# 条件
# x^2 +y^2 =nを満たすnが良い
# これは円なのでは？？

# N以下にk個
# 最後に昇順ソートが必要
# ただし、k=0だと空行する必要あり

# 0<x<yを守るようにしないといけない
# xとyのループを回す。
# その後n = x^2+y^2の計算をする
# nの回数をカウントする

# どこまで回すかも考える
# 条件１
# 0<x<y
# 条件２
# x^2+y^2 =N


count = [0]*(N+1)
# これ紙が必要
# xの範囲を指定しないといけない
for x in range(1,int((N/2)**0.5)+1):
  for y in range(x+1, int((N - x**2)**0.5)+1):
    n = x**2+y**2
    if n <= N:
      count[n] += 1

# とりあえずこれで考えてみる
# 2
# 5 10


# 反省
# ロジック解体と標準入力の受け取りは結構な精度できるようになった
# ただ、実装力がまだまだ足りない
# setとかをもっと使ってなれる必要がある